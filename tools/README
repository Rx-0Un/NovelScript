# 如何用JavaScript写一个趋于精确的计时器

与大多数不支持进程与线程的编程语言一样，JavaScript语言标准也附带了一个可以引用的定时器/计时器。用于在某段时间之后执行某个函数的`setTimeout`，以及用于每间隔某段时间执行某个函数的`setInterval`，这两个函数提供了基于异步的基本的计时器功能。

JavaScript自带的计时器能够提供模糊的计时和定时功能，这种模糊性使它们非常不准确，即使以一秒为间隔重复执行一向工作，在数次计时后，就会与真实的时间产生偏差。在需要准确计时的场景，只是用`setInterval`将会带来绝大的延迟。

```javascript
setInterval(function(){
  ...
}, 50)
```

这段代码以50毫秒为间隔执行某段代码，在执行20次后，真实时间已经过去了5秒钟，浏览器的CPU占用量超过了20%（Intel Core i5-5257U）。

所以要让JavaScript能够准确计时，只使用`setInterval`是不行的。

JavaScript不能获得CPU时钟，或者像C语言一样能够进行大量的System Call，我们只能通过系统时间来获得一个正确的时钟，JavaScript标准中`Date`对象能够获得系统时间，例如`Date.now()`能够获得代表当前时间的精确到毫秒的时间戳。

在刚才的代码实例中，我们可以在每次执行的时候通过`Date.now()`获得一个时间戳，时间戳是一个精确到毫秒的整数，如果代码中的计时器完全精确，每次获得的时间戳相比前次，两者的差应当是1000。

我们可以把这一命题作为判断计时器准确与否的标准，即：

```
一个准确的计时器，若记录器每次执行时的时间戳，那么其每次执行与上一次执行产生的时间戳的差，应该等于计时器记录的时间间隔。
```

也就是说上面代码中的计时器，如果它是准确的，它每次执行与上次执行产生的时间戳，应该是50。

当然代码中的计时器不精确，所以每次获得的数字与50存在少量误差，这种误差积少成多，最后导致了计时器的失准。

所以我们的核心思路是：

```
既然每次计时的误差不可避免，我们希望这种误差是独立的，不会累积到下一次计时。
```

JavaScript自带的计时器不准确是既定的，在只能保留这种基本方法的前提下，如果希望两次执行的时间戳的差能趋近于50，我们能够更改的只有每次执行的间隔。

```
例如，某次执行时距离上次的时间差是51，那么我们希望下次执行是在49毫秒之后，这样两次执行共花费100毫秒，平均每次50毫秒。
```

使用`setInterval`无法改变这种间隔，我们需要把上面的代码用`setTimeout`改写：

```javascript
function counter(){
  ...
  setTimeout(counter, ?)
}
setTimeout(counter, unit)
```

我们希望修改的是问号里的数值，也就是每次执行后距离下一次执行的时间，为了得到这个数值，我们从最初开始模拟这个过程。为了表达上的便利，下面的代码中使用全局变量：

#### 计时开始：

```javascript
start = Date.now(); // 获取当前系统时间
setTimeout(counter, unit); // 开始计时
```

`unit`代表单位间隔时间，就是计时器每次计时的理论间隔时间。

#### 首次执行：

```javascript
current = Date.now(); // 获取此次执行时的系统时间
tmp = current - start; // 计算此次执行与最开始时的差距
start += unit; // 计算此次执行时正确的系统时间
```

此处我们选择了`start += unit`而不是终于刚才的结论的`start = current`的原因是，我们希望刚才结论中的理想计时器每次都是准确的，而此处的真实计时器并不准确，一个准确的计时器每次执行，时间戳都会增加等同于间隔的时间，所以我们直接写`start += unit`。

#### 预设再次执行：

```javascript
setTimeout(counter, unit-(tmp-unit));
```

通过计算，下一次执行应该在`unit-(tmp-unit)`之后。或者按照上面例子里写作`2*unit - tmp`。

到这里我们已经有了一个接近准确的计时器了。实际上操作系统中的各种行为都会产生运算时间，比如在内存中写入一个变量，让cpu完成一次计算，甚至cpu排序进程，mmu分配内存都会导致额外的时间，也就是计时器的失准，从减少运算和变量出发，我们可以将刚才的程序改写为：

```javascript
function counter(){
  start+=unit;
  setTimeout(counter, unit+start-(Date.now()));
}
setTimeout(counter, unit)
```

这个计时器与文件夹中的counter.js相同， 误差为每千秒+-10毫秒，每次结果的误差是独立的不会累计，cpu占用率2%。

附：计算的过程

```
  s' = s + u  <=> s' = s - u
  u - (t - u)
= 2u - t
= 2u - (c - s)
= 2u + s - c
= 2u + s' - u - c
= u + s' - c
```

